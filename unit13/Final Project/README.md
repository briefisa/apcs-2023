# Project: Implement the Fast Fourier Transform for rapid processing of signal convolution
## Why? / What?
A convolution is a method of combining two functions into one that is prevalant throughout signal processing. Convolutions can be found everywhere from digital audio processing (reverb, eq, etc.), to image processing, to neural networks, so it's a pretty applicable topic. With this in mind, I wanted to learn more about how convolutions work and how they're implemented. In the end, I created a working method that can sample an 'audio' signal (not actually audio because that requires c++) at thousands of different locations, then perform a discrete fourier transform on these points (leveraging a Fast Fourier Transform algorithm coded by yours truly to vastly speed up the computation time, from O(N^2) to O(NlogN)). Because of some clever math stuff, you can process convolutions much faster by using a discrete fourier transform than by just doing it the brute force way (in my tests, my fft algorithm was around 70 times faster than my 'dumb', non-fft convolution algorithm).

## What I Learned
I learned a huge amount about both Python, a language I was unfamiliar with, and the DFT, FFT, and Convolutions (all three of which are incredibly prevalant and important algorithms in modern civilization). Having to actually code the fast fourier transform algorithm really forced me to think about it more than I otherwise would have, increasing my understanding a lot. As far as coding, I became a lot more comfortable with python, and learned how to do some cool stuff, like MatPlotLib, Numpy, and complex numbers.

## How To Try It
Unfortunately, as far as I can tell matplotlib doesn't work in codespaces, so to make pretty convolution graphs you'll have to use a non web-based ide. However, if you do end up doing this, you can make your own functions or change function1 and kernelFunction to change the convolution. You can also mess with the parameters in the fft_convolution method call (sorry it's very confusing), like sampleRate or packetSize, and see how these affect the resulting graph and runtime. Finally, if you want to 'race' the fft convolution algorithm with the 'dumb' convolution, I made a second algorithm that can process the same convolution and is a pretty cool demonstration of how much more efficient the fft makes the algorithm. If you get matplotlib working, it's fun to mess around with the kernel function and the kernel width and see how that changes the effects of the convolution.
